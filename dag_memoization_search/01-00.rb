# フィボナッチ数列 (paizaランク B 相当)
# https://paiza.jp/works/mondai/dag_memoization_search/dag_memoization__problems_step0

INPUT1 = <<"EOS"
10
EOS
OUTPUT1 = <<"EOS"
55
EOS

INPUT2 = <<"EOS"
1
EOS
OUTPUT2 = <<"EOS"
1
EOS

INPUT3 = <<"EOS"
100000
EOS
OUTPUT3 = <<"EOS"
911435502
EOS

# 割る数
DIV = 1_000_000_007
# 入力 (1 ≦ N ≦ 100,000)
N = n = gets.to_i

# memo, stack 初期化
memo = [0, 1]
stack = [N]

# 解答できる (n=2) まで n を小さくしていく
stack.push n -= 1 while !(memo[n - 1] && memo[n - 2])

# N 項までのフィボナッチ数を求めて memo に格納
while stack.length > 0
  n = stack.pop
  memo[n] = memo[n - 1] + memo[n - 2]
end

# N 項のフィボナッチ数を出力
puts memo[N] % DIV

=begin
# 割る数
DIV = 1_000_000_007
# 入力 (1 ≦ N ≦ 100,000)
n = gets.to_i

# n 項までのフィボナッチ数を求める
memo = [0, 1]
(n - 1).times { memo << memo[-1] + memo[-2] }

# 出力
puts memo[n] % DIV
=end

=begin
問題にチャレンジして、ユーザー同士で解答を教え合ったり、コードを公開してみよう！

シェア用URL:
問題文のURLをコピーする
 下記の問題をプログラミングしてみよう！
1 以上 100,000 以下の数値 N が与えられます。フィボナッチ数列 の N 項目の数を求めてください。
答えは非常に大きくなることがあるので、 1,000,000,007 で割ったあまりを出力してください。

ここで、フィボナッチ数列の 1 項目は 1 、 2 項目も 1 、 3 項目は 2 とします。

この問題はさまざまな実装方法がありますが、メモ化再帰を用いて実装してみましょう！

▼　下記解答欄にコードを記入してみよう

入力される値
N


・ 1 行目に、数値 N が与えられます。

入力値最終行の末尾に改行が１つ入ります。
文字列は標準入力から渡されます。 標準入力からの値取得方法はこちらをご確認ください
期待する出力
フィボナッチ数列の N 項目の数を求めてください。答えは非常に大きくなることがあるので、 1,000,000,007 で割ったあまりを出力してください。

また、末尾に改行を入れ、余計な文字、空行を含んではいけません。

条件
すべてのテストケースにおいて、以下の条件をみたします。

・ 入力はすべて整数
・ 1 ≦ N ≦ 100,000

入力例1
10

出力例1
55

入力例2
1

出力例2
1

入力例3
100000

出力例3
911435502
=end
