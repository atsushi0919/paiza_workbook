# 最安値を達成するには 2 (paizaランク B 相当)
# https://paiza.jp/works/mondai/dp_primer/dp_primer_apples_step1

INPUT1 = <<~"EOS"
  4 110 200
EOS
OUTPUT1 = <<~"EOS"
  200
EOS

def solve(input_data)
  n, a, b = input_data.split.map(&:to_i)

  # dpテーブル初期化
  # 0 個購入: 0 円
  dp = [0]

  # dpテーブル更新
  1.upto(n + 4) do |i|
    dp_x = i > 2 ? dp[i - 2] + a : a
    dp_y = i > 5 ? dp[i - 5] + b : b

    # 2個買った場合と5個買った場合で安い方を記録する
    dp << [dp_x, dp_y].min
  end

  # n 個以上購入時の最安値を返す
  #dp[n..].min
  dp
end

#puts solve(STDIN.read)

# 確認用コード
p solve(INPUT1)
# > 200

=begin
最安値を達成するには 2 (paizaランク B 相当)
問題にチャレンジして、ユーザー同士で解答を教え合ったり、コードを公開してみよう！

シェア用URL:
https://paiza.jp/works/mondai/dp_primer/dp_primer_apples_step1
問題文のURLをコピーする
 チャレンジする言語

得意な言語を選択してください
コードを書いて解いてみる
 チケット使用済
問題
 下記の問題をプログラミングしてみよう！
八百屋にて、りんご2個が a 円で、りんご5個が b 円で売られています。
りんごの買い方を工夫したとき、n 個のりんごを手に入れるために必要な金額の最小値はいくらでしょうか。
なお、買い方を工夫した結果、買ったりんごが n+1 個以上になってもよいものとします。

(ヒント)
前問の八百屋ではりんごが1個と2個で売られていましたが、本問の八百屋では2個と5個で売られています。
この変更により、前問と同じようにして解こうとするとうまくいかなくなりました。理由を考えてみてください。

前問と同じように dp[n] をちょうど n 個のりんごを買うのに必要な金額の最小値とすると、dp[3] の値が正しく計算されないことがわかります。
これは、りんごは2個ずつか5個ずつでしか買うことが出来ないため、3個のりんごをちょうど買う方法が存在しないからです。
では、どうしたら dp[3] のような、2と5の組合せでは作れないような個数について最安値を計算することが出来るでしょうか。

問題文の最後の文に注目すると、買うりんごの数が3個以上になってもよいことがわかるので、ここで dp2[n] を n 個以上のりんごを買うのに必要な金額の最小値としてみましょう。
dp と dp2 の定義から、dp2[n] = min(dp[n], dp[n+1], ...) であることがわかります。dp2[n] が求めたい答えになっています。

dp は dp[n] までではなく、余裕をもって dp[n+4] 程度まで計算しておく必要があることに注意しましょう
(実はこの問題においては dp[n+2] まで計算しておけば十分なのですが、ある程度多めに計算しておくと安心です) 。
また、実は新しく dp2 という配列を用意せずとも、dp をうまく書き換えることで答えを求めることもできます。
余裕があれば考えてみてください (ヒント:ループを回す順番を工夫) 。

入力される値
n a b

入力値最終行の末尾に改行が１つ入ります。
文字列は標準入力から渡されます。 標準入力からの値取得方法はこちらをご確認ください
期待する出力
りんごを n 個手に入れるために必要な金額の最小値を出力してください。

また、末尾に改行を入れ、余計な文字、空行を含んではいけません。

条件
すべてのテストケースにおいて、以下の条件をみたします。

・ 1 ≦ n ≦ 1,000

・ 1 ≦ a ≦ 10,000

・ 1 ≦ b ≦ 10,000

・ a < b

入力例1
4 110 200

出力例1
200
=end
